/****************************************************************************
Файл: OW.h
Creted by PROTTOSS
Mail to PROTTOSS@mail.ru
модуль интерфейса DALLAS 1-Wire
09.01.2006

!!! Внимание !!!
Обязательно биты OW_WIRE в портах OW_PORT и PORTD должны быть очищены,
к линии OW_WIRE должен быть подключен подтягивающий резистор номиналом 4,7кОм
*****************************************************************************/

#include "main.h"
#include "OneWire.h"


/*****************************************************************************
Задержки Bit в микросекундах Transfer Layer, рекомендованные в AN126 от Dallas Semicondactors
и в AN318 от ATMEL
*****************************************************************************/
#define OW_DEL_A        6
#define OW_DEL_B        64
#define OW_DEL_C        60
#define OW_DEL_D        10
#define OW_DEL_E        9
#define OW_DEL_F        55
#define OW_DEL_G        0
#define OW_DEL_H        480
#define OW_DEL_I        70
#define OW_DEL_J        410
/*****************************************************************************
Прототипы функций
*****************************************************************************/


// external
void UTIL_WaitTimeInUs(unsigned long mck, unsigned int time_us);

void OW_Init(void);     // Инициализация
void OW_WriteBit1(void); // запись на шину 1
void OW_WriteBit0(void); // запись на шину 0
bool OW_ReadBit(void); // чтение бита с шины

void OW_SendByte(char data); // посылка байта
bool OW_DetectPresence(void);// сброс и определение устройства на шине
char OW_ReceiveByte(void); // прием байта с линии


#define BUS_SET_0       BIT_SET(DDRD, PD_TM)
#define BUS_RELEASE     BIT_CLR(DDRD, PD_TM)
#define BUS_GETPIN      BIT_TEST(PIND,PD_TM)


/*****************************************************************************
Запись на шину 1
Шина должна быть установлена в 0 на время 1-15 мкс
*****************************************************************************/
void OW_WriteBit1(void) {
    BUS_SET_0; // устанавливаем шину в ноль
    UTIL_WaitTimeInUs(BOARD_MCK,OW_DEL_A);// задержка A нахождения шины в 0
    BUS_RELEASE;//  освобождаем шину
    UTIL_WaitTimeInUs(BOARD_MCK,OW_DEL_B);// задержка B до окончания таймслота
}

/*****************************************************************************
Запись на шину 0
Шина должна быть установлена в 0 на время 60-120 мкс
*****************************************************************************/
void OW_WriteBit0(void) {
    BUS_SET_0;// устанавливаем шину в ноль
    UTIL_WaitTimeInUs(BOARD_MCK,OW_DEL_C);// задержка C нахождения шины в 0
    BUS_RELEASE;//  освобождаем шину
    UTIL_WaitTimeInUs(BOARD_MCK,OW_DEL_D);// задержка D до окончания таймслота
}

/*****************************************************************************
Сигнал чтения шины
Шина должна быть установлена в 0 на время 1-15 мкс. После этого, в течении
15 мкс устройство должно удерживать шину в 0, если требуется послать 0, если
требуется послать 1, устройство не подает никаких сигналов по шине
Выход:  status содержит состояние шины (0 при 0 или не 0 при 1)
******************************************************************************/
bool OW_ReadBit(void){
    bool status;
    BUS_SET_0;// устанавливаем шину в ноль
    // задержка A нахождения шины в 0
    UTIL_WaitTimeInUs(BOARD_MCK,OW_DEL_A);
    BUS_RELEASE;//  освобождаем шину

    // задержка E до удержания датчиком сигнала на линии
    UTIL_WaitTimeInUs(BOARD_MCK,OW_DEL_E);

    // читаем состояние шины
    status = BUS_GETPIN != 0;

    // задержка F до окончания таймслота
    UTIL_WaitTimeInUs(BOARD_MCK,OW_DEL_F);

    return status;
}

/*****************************************************************************
Посылка байта в устройство
*****************************************************************************/
void OW_SendByte(char data)
{   char count;

    // формируем счетчик бит
    count = 8;

    // цикл вывода бит на шину
    do
    {   //выводим очередной бит начиная с младшего
        if(data & 0x01)
        {   OW_WriteBit1();
        }
        else
        {   OW_WriteBit0();
        }

        // сдвигаем данные вправо и проверяем окончание цикла
        data >>= 1;
    }
    while(--count);
}

/*****************************************************************************
Определение устройства на шине. Возвращает байт, установленные биты в котором
означают обнаруженные устройства
*****************************************************************************/
bool OW_DetectPresence(void)
{   bool status;
    // если шина в нуле, то считаем что нет датчика
    if (BUS_GETPIN == 0) {
        return false;
    }

    BUS_SET_0;// устанавливаем шину в ноль
    // задержка H нахождения шины в 0
    UTIL_WaitTimeInUs(BOARD_MCK,OW_DEL_H);
    //  освобождаем шину
    BUS_RELEASE;

    // задержка I до окончания таймслота
    UTIL_WaitTimeInUs(BOARD_MCK,OW_DEL_I);

    // читаем состояние шины
    status = (BUS_GETPIN  == 0);

    // задержка J до окончания таймслота
    UTIL_WaitTimeInUs(BOARD_MCK,OW_DEL_J);

    return status;
}

/*****************************************************************************
Прием байта из устройства.
Возвращает принятый байт.
*****************************************************************************/
char OW_ReceiveByte(void)
{
    U8 count;
    U8 data;

    //формируем счетчик бит
    count = 8;

    // цикл чтения бит с шины
    do
    {   // сдвигаем данные вправо
        data >>= 1;

        // формируем бит в байте данных
        if(OW_ReadBit())
        {   data |= 0x80;
        }
    }
    while(--count);

    return data;
}

void UTIL_WaitTimeInUs(unsigned long mck, unsigned int time_us){
    while (time_us--) {
        __delay_cycles(10);
    }
}



